---
layout: post
title: 深入理解JVM笔记!
---

### 类加载的过程
![过程](https://github.com/Victooory/victooory.github.io/raw/master/img/JVM1.png)
**装载**：查找并加载类的二进制数据 <br>
**链接**：<br>
1.**验证**：确保被加载类的正确性(安全考虑，编译器生成的class是符合JVM字节码的，但是防止非编译器生成的class文件) <br> 
2.**准备**：为类的静态变量分配内存，并将其初始化为默认值 <br> 
3.**解析**：把类中的符号引用转换为直接引用 <br> 
**初始化**：为类的静态变量赋予正确的初始值

### java虚拟机在运行时数据在内存中的分区
![分区](https://github.com/Victooory/victooory.github.io/raw/master/img/JVM2.png)
**程序计数器**：当前线程所执行字节码的行号指示器 <br>
**java虚拟机栈**：Java方法执行的内存模型，方法的生命周期对应一个栈帧(存放局部变量表、操作数栈、动态链接、方法出口)在虚拟机栈中入栈到出栈的过程 </br>
**本地方法栈**：和虚拟机栈相似，为虚拟机使用到的Native方法服务 <br>
**java堆**：被所有线程共享的内存区域，在虚拟机启动时创建，用来存放对象实例以及数组，垃圾收集器管理的主要区域(GC堆) <br>
**方法区**：各个线程共享的内存区域，存储已被虚拟机加载的类信息(常量、静态变量、即时编译器变异后的代码等数据) <br>
**运行时常量池**：Class文件中除了有 类的版本、字段、方法、接口等描述信息外还有一个常量池，用于存放编译器生成的各种字面量的符号和引用 <br>
**直接内存**：堆外内存

### 回收算法
对于回收算法 JVM没有选用引用计数的原因是它很难解决对象之间互相循环引用的问题 <br>
JVM用的是可达性分析算法通过"GC root"作为起点，从起点向下搜索，当一个对象到GCroot 没有任何引用链相连时，则此对象不可达
